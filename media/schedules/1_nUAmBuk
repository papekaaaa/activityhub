import torch                                                                                   # pyright: ignore[reportMissingImports]
import torch.nn as nn                                                                              # pyright: ignore[reportMissingImports]
import torch.optim as optim                                                                             # type: ignore
from torchvision import datasets, transforms                                                  # type: ignore

# MNIST (only digits 0 and 1)
transform = transforms.Compose([transforms.ToTensor(), 
                                transforms.Lambda(lambda x: x.view(-1))])

trainset = datasets.MNIST(root='./data', train=True, 
                          download=True, transform=transform)
mask = (trainset.targets == 0) | (trainset.targets == 1)
trainset.data, trainset.targets = trainset.data[mask], trainset.targets[mask]

trainloader = torch.utils.data.DataLoader(trainset, batch_size=32, shuffle=True)

# Perceptron model
class Perceptron(nn.Module):
    def __init__(self):
        super().__init__()
        self.fc = nn.Linear(28*28, 1)

    def forward(self, x):
        return torch.sigmoid(self.fc(x))

model = Perceptron()
criterion = nn.BCELoss()
optimizer = optim.SGD(model.parameters(), lr=0.1)

# Training loop
for epoch in range(5):
    for data, target in trainloader:
        y = target.float().unsqueeze(1)  # match shape
        optimizer.zero_grad()
        output = model(data)
        loss = criterion(output, y)
        loss.backward()
        optimizer.step()

print("Training complete!")